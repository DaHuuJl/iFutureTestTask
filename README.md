# Тестовое задание

Цель: Создание многопоточного сервиса и оценка его производительности.

Функционал сервиса. Сервис должен хранить, обновлять и получать значение банковского счёта по указанному идентификатору
используя следующий интерфейс:

```java
/**
* Интерфейс сервиса для работы с банковским счётом содержит два метода
**/
interface BalanceService {
    /**
    * Получение баланса
    *
    * @param id идентификатор банковского счёта
    * @return сумма денег на банковском счёте
    */
    Optional<Long> getBalance(Long id);
    /**
    * Изменение баланса на определённое значение
    *
    * @param id идентификатор банковского счёта
    * @param amount сумма денег, которую нужно добавить к банковскому счёту
    */
    void changeBalance(Long id, Long amount);
}
```

Требования к функционалу сервиса:
- Сервис должен сохранять состояние счетов в базе данных.
- Нужно предусмотреть кэширование данных.
- Сервис должен работать в многопоточном режиме и корректно обрабатывать параллельные запросы, в том числе к одному банковскому счёту.
- Предполагается, что метод getBalance учитывает результаты всех успешно завершившихся ранее методов changeBalance.
- Сервис должен быть максимально высокопроизводительным, т.е. обрабатывать как можно большее количество запросов в единицу времени.

На стороне сервиса нужно подсчитывать количество запросов getBalance, changeBalance и их сумму в единицу времени. 
Результат записывать в лог. Для оценки производительности сервиса нужно реализовать клиента, который в несколько потоков 
выполняет бесконечный цикл. В цикле выполняется случайно выбранный запрос getBalance или changeBalance. 
Параметры для этих запросов выбираются из списка также случайным образом.

Требуются следующие настройки:
- threadCount - количество клиентских потоков (>= 1)
- readQuota   - доля запросов getBalance (>= 0)
- writeQuota  - доля запросов changeBalance (>= 0)
- readIdList  - список идентификаторов для getBalance
- writeIdList - список идентификаторов для changeBalance

Требования к инструментарию
- Java или Kotlin любой версии
- Использование или не использование SpringBoot’а и других framework’ов не принципиально
- Можно использовать любые библиотеки
- Можно использовать любые базы данных, брокеры сообщений и прочие сервисы
- Можно использовать любые протоколы общения между клиентом и сервером (http, hessian, rest, grpc, netty, rmi, socket’ы)

Пожелания к реализации
- Используйте единый git-репозиторий для клиента и сервера
- Обдуманно относитесь к решениям на просторах интернета, там накапливаются и неправильные ;)
- Можно задавать вопросы

## Кастомные переменные 
`ACCOUNT_READ_LIST` - список идентификаторов для getBalance

`ACCOUNT_WRITE_LIST` - список идентификаторов для changeBalance

`ACCOUNT_READ_QUOTA` - лист вероятностей для чтения

`ACCOUNT_WRITE_QUOTA` - лист вероятностей для записи

`CLIENT_THREAD_COUNT` - количество клиентов 

`CLIENT_THREAD_SAME_QUOTA` - если это флаг принимает значение `true`, то для всех клиентов устанавливается одинаковая
вероятность, а если `false` - то для каждого клиента нужно задать свою вероятность (так же программа упадёт, если
при значении `false` количество элементов в `ACCOUNT_READ_QUOTA` и `ACCOUNT_WRITE_QUOTA` не равны `CLIENT_THREAD_COUNT`)

`BANK_SERVER_PORT` - порт localhost на котором запущен клиент

`ANALYTICS_TIME` - время за которое выводится аналитика в мс 
(например, если `ANALYTICS_TIME=10000`, интервал между логами будет 10 секунд)


## Запуск через Docker

В корневой директории запускаем команду:

```
 docker-compose up
```

## Создание БД в PostgreSQL

Запустить psql или PgAdmin. Авторизоваться, после (для PgAdmin) выбрать бд `postgres` и нажать на `Query Tool` (кнопка над сервером).
Создадим базу данных:

```
CREATE DATABASE ifuture_db;
```

Создание пользователя:

```
CREATE USER owner_ifuture_db WITH PASSWORD 'owner_ifuture_db';
```

Выделение прав пользователю:

```
GRANT ALL PRIVILEGES ON DATABASE "ifuture_db" to owner_ifuture_db;
```

Или сделать пользователя суперюзером:

```
ALTER USER owner_ifuture_db WITH SUPERUSER;
```